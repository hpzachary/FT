<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fighter Search</title>
</head>
<body>
    <h1>Fighter Search</h1>
    <label for="name">Name:</label>
    <input type="text" id="name" value="">
    <button id="getInfo">Get Info</button>

    <div id="result"></div>

    <script>
        const leagueIds = [4443, 4445, 4567, 5430]; // UFC, Boxing, BKFC, PFL

        document.getElementById('getInfo').addEventListener('click', fetchFighterInfo);

        async function fetchFighterInfo() {
            const name = document.getElementById('name').value.trim();
            if (!name) return alert('Please enter a name');

            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = 'Loading...';

            try {
                // Fetch events
                const eventsResponse = await fetch(`https://www.thesportsdb.com/api/v1/json/1/searchfilename.php?e=${encodeURIComponent(name)}`);
                const eventsJson = await eventsResponse.json();
                let events = eventsJson.event || [];
                events = events.filter(e => leagueIds.includes(parseInt(e.idLeague)));

                if (events.length === 0) throw new Error('No data found for this fighter in the specified organizations');

                // Fetch player bio
                const playerResponse = await fetch(`https://www.thesportsdb.com/api/v1/json/1/searchplayers.php?p=${encodeURIComponent(name)}`);
                const playerJson = await playerResponse.json();
                const player = playerJson.player ? playerJson.player[0] : null;
                const bio = player ? player.strDescriptionEN || '' : '';

                // Parse amateur record from bio
                let amateurWins = 0, amateurLosses = 0, amateurDraws = 0;
                const amateurMatch = bio.match(/amateur record of (\d+)-(\d+)(-(\d+))?/i);
                if (amateurMatch) {
                    amateurWins = parseInt(amateurMatch[1]);
                    amateurLosses = parseInt(amateurMatch[2]);
                    amateurDraws = parseInt(amateurMatch[4] || 0);
                }

                const currentDate = new Date('2026-02-20'); // Use current date in code; adjust if needed

                const pastFights = events.filter(e => new Date(e.dateEvent) < currentDate).sort((a, b) => new Date(b.dateEvent) - new Date(a.dateEvent));
                const futureFights = events.filter(e => new Date(e.dateEvent) >= currentDate).sort((a, b) => new Date(a.dateEvent) - new Date(b.dateEvent));

                // Parse past fights
                const pastParsed = pastFights.map(e => parseFight(e, name)).filter(Boolean);

                const total = pastParsed.length;
                if (total === 0) throw new Error('No past fights found');

                const wins = pastParsed.filter(f => f.won).length;
                const losses = pastParsed.filter(f => !f.won && !f.isDraw).length;
                const draws = total - wins - losses;
                const koWins = pastParsed.filter(f => f.won && f.isKO).length;
                const subWins = pastParsed.filter(f => f.won && f.isSub).length;
                const titleWins = pastParsed.filter(f => f.won && f.isTitle).length;
                const closeLosses = pastParsed.filter(f => !f.won && f.isDecision && f.isSplit).length;
                const decisiveLosses = losses - closeLosses;

                // Calculate rating
                let rating = 50 + (wins / total * 30) + (koWins + subWins) / total * 10 + titleWins * 2 - (decisiveLosses / total * 20) - (closeLosses / total * 10);
                if (amateurWins) rating += (amateurWins - amateurLosses) / (amateurWins + amateurLosses + amateurDraws + 1) * 10;
                rating = Math.min(100, Math.max(1, Math.round(rating)));

                // Next fight
                let nextFightDate = 'N/A';
                let nextOpponent = 'N/A';
                let opponentRecentRecord = 'N/A';
                let nextTitles = '';

                if (futureFights.length > 0) {
                    const nextFight = parseFight(futureFights[0], name);
                    nextFightDate = futureFights[0].dateEvent;
                    nextOpponent = nextFight.opponent;
                    nextTitles = await getCurrentTitles(nextOpponent);
                    opponentRecentRecord = await getRecentRecord(nextOpponent);
                }

                // Last opponent
                let lastOpponent = 'N/A';
                let lastTitles = '';
                if (pastParsed.length > 0) {
                    lastOpponent = pastParsed[0].opponent;
                    lastTitles = await getCurrentTitles(lastOpponent); // Historical, but using current for simplicity
                }

                // Fights in last two years
                const twoYearsAgo = new Date(currentDate);
                twoYearsAgo.setFullYear(twoYearsAgo.getFullYear() - 2);
                const numLastTwoYears = pastFights.filter(e => new Date(e.dateEvent) > twoYearsAgo).length;

                // Display
                resultDiv.innerHTML = `
                    Overall Rating for ${name}: ${rating}<br>
                    Next Fight Date: ${nextFightDate}<br>
                    Next Opponent: ${nextOpponent}${nextTitles}<br>
                    Opponent Recent Record: ${opponentRecentRecord}<br>
                    Last Opponent: ${lastOpponent}${lastTitles}<br>
                    Number of Fights In Last Two Years: ${numLastTwoYears}
                `;
            } catch (error) {
                resultDiv.innerHTML = '';
                alert('Error: ' + error.message);
            }
        }

        function parseFight(event, fighterName) {
            const strEvent = event.strEvent || '';
            const vsIndex = strEvent.indexOf(' vs ');
            if (vsIndex === -1) return null;

            const fighter1 = strEvent.substring(0, vsIndex).trim();
            const fighter2 = strEvent.substring(vsIndex + 4).trim();

            const isFighter1 = fighter1.toLowerCase().includes(fighterName.toLowerCase());
            if (!isFighter1 && !fighter2.toLowerCase().includes(fighterName.toLowerCase())) return null;

            const opponent = isFighter1 ? fighter2 : fighter1;

            const result = event.strResult || '';
            const lowerResult = result.toLowerCase();
            const won = lowerResult.includes(fighterName.toLowerCase()) && (lowerResult.includes('def.') || lowerResult.includes('winner'));
            const isDraw = lowerResult.includes('draw');
            const methodMatch = result.match(/by (.+)/i);
            const method = methodMatch ? methodMatch[1].toLowerCase() : '';
            const isKO = method.includes('ko') || method.includes('tko');
            const isSub = method.includes('submission');
            const isDecision = method.includes('decision');
            const isSplit = method.includes('split');
            const isUnanimous = method.includes('unanimous');
            const isTitle = strEvent.toLowerCase().includes('championship') || strEvent.toLowerCase().includes('title');

            return { opponent, won, isDraw, isKO, isSub, isDecision, isSplit, isUnanimous, isTitle };
        }

        async function getRecentRecord(name) {
            try {
                const eventsResponse = await fetch(`https://www.thesportsdb.com/api/v1/json/1/searchfilename.php?e=${encodeURIComponent(name)}`);
                const eventsJson = await eventsResponse.json();
                let events = eventsJson.event || [];
                events = events.filter(e => leagueIds.includes(parseInt(e.idLeague)));

                const currentDate = new Date('2026-02-20');
                const pastFights = events.filter(e => new Date(e.dateEvent) < currentDate).sort((a, b) => new Date(b.dateEvent) - new Date(a.dateEvent));

                const pastParsed = pastFights.slice(0, 3).map(e => parseFight(e, name)).filter(Boolean);

                return pastParsed.map(f => (f.won ? 'W' : (f.isDraw ? 'D' : 'L')) + ` (${f.opponent})`).join(' - ');
            } catch {
                return 'N/A';
            }
        }

        async function getCurrentTitles(name) {
            const pages = {
                ufc: 'List_of_UFC_champions',
                boxing: 'List_of_current_world_boxing_champions',
                bkfc: 'Bare_Knuckle_Fighting_Championship',
                pfl: 'Professional_Fighters_League'
            };

            let titles = '';

            for (const org in pages) {
                try {
                    const response = await fetch(`https://en.wikipedia.org/w/api.php?action=parse&format=json&prop=text&section=0&page=${pages[org]}&formatversion=2&origin=*`);
                    const json = await response.json();
                    const html = json.parse.text;
                    if (html.toLowerCase().includes(name.toLowerCase()) && html.toLowerCase().includes('champion')) {
                        titles += ` (${org.toUpperCase()} Champion)`;
                    }
                } catch {}
            }

            return titles;
        }
    </script>
</body>
</html>